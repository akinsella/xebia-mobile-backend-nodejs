// Generated by CoffeeScript 1.6.3
var ExperienceLevel, Presentation, PresentationType, Room, ScheduleEntry, Speaker, Track, async, baseUrl, config, db, eventId, moment, processDevoxxExperienceLevels, processDevoxxPresentationTypes, processDevoxxPresentations, processDevoxxRooms, processDevoxxSchedule, processDevoxxSpeakers, processDevoxxTracks, request, synchronize, synchronizeDevoxxExperienceLevel, synchronizeDevoxxPresentation, synchronizeDevoxxPresentationType, synchronizeDevoxxRoom, synchronizeDevoxxScheduleEntry, synchronizeDevoxxSpeaker, synchronizeDevoxxTrack, utils, _;

async = require('async');

moment = require("moment");

_ = require('underscore')._;

request = require("request");

config = require("../conf/config");

utils = require('../lib/utils');

db = require("../db");

ExperienceLevel = require("../model/experienceLevel");

PresentationType = require("../model/presentationType");

Track = require("../model/track");

Speaker = require("../model/speaker");

Presentation = require("../model/presentation");

Room = require("../model/room");

ScheduleEntry = require("../model/scheduleEntry");

eventId = 10;

baseUrl = "http://dev.cfp.devoxx.com:3000";

synchronize = function() {
  var callback;
  callback = function(err, results) {
    if (err) {
      return console.log("Devoxx Belgium Synchronization ended with error: " + err.message + " - Error: " + err);
    } else {
      return console.log("Devoxx Belgium Synchronization ended with success !");
    }
  };
  if (config.feature.stopWatch) {
    callback = utils.stopWatchCallbak(callback);
  }
  console.log("Start synchronizing Devoxx Belgium data ...");
  return async.parallel([processDevoxxExperienceLevels, processDevoxxPresentationTypes, processDevoxxTracks, processDevoxxSpeakers, processDevoxxPresentations, processDevoxxRooms, processDevoxxSchedule], callback);
};

processDevoxxExperienceLevels = function(callback) {
  console.log("Start synchronizing Devoxx Experience Levels ...");
  return request.get({
    url: "" + baseUrl + "/rest/v1/events/" + eventId + "/experiencelevels",
    json: true
  }, function(error, data, response) {
    var experienceLevels;
    experienceLevels = _(response).sortBy(function(experienceLevel) {
      return experienceLevel.Name.toUpperCase();
    });
    experienceLevels.forEach(function(experienceLevel) {
      return experienceLevel.conferenceId = eventId;
    });
    return async.map(experienceLevels, synchronizeDevoxxExperienceLevel, function(err, results) {
      return console.log("Synchronized " + results.length + " Experience Levels");
    });
  });
};

processDevoxxPresentationTypes = function(callback) {
  console.log("Start synchronizing Devoxx Presentation Types ...");
  return request.get({
    url: "" + baseUrl + "/rest/v1/events/" + eventId + "/presentationtypes",
    json: true
  }, function(error, data, response) {
    var presentationTypes;
    presentationTypes = _(response).sortBy(function(presentationType) {
      return presentationType.name.toUpperCase();
    });
    presentationTypes.forEach(function(presentationType) {
      presentationType.conferenceId = eventId;
      return presentationType.descriptionPlainText = utils.htmlToPlainText(presentationType.description);
    });
    return async.map(presentationTypes, synchronizeDevoxxPresentationType, function(err, results) {
      return console.log("Synchronized " + results.length + " Presentation Types");
    });
  });
};

processDevoxxTracks = function(callback) {
  console.log("Start synchronizing Devoxx Tracks...");
  return request.get({
    url: "" + baseUrl + "/rest/v1/events/" + eventId + "/tracks",
    json: true
  }, function(error, data, response) {
    var tracks;
    tracks = _(response).sortBy(function(track) {
      return track.name.toUpperCase();
    });
    tracks.forEach(function(track) {
      track.conferenceId = eventId;
      return track.descriptionPlainText = utils.htmlToPlainText(track.description);
    });
    return async.map(tracks, synchronizeDevoxxTrack, function(err, results) {
      return console.log("Synchronized " + results.length + " Tracks");
    });
  });
};

processDevoxxSpeakers = function(callback) {
  console.log("Start synchronizing Devoxx Speakers ...");
  return request.get({
    url: "" + baseUrl + "/rest/v1/events/" + eventId + "/speakers",
    json: true
  }, function(error, data, response) {
    var speakers;
    speakers = _(response).sortBy(function(speaker) {
      return ("" + speaker.firstName + " " + speaker.lastName).toUpperCase();
    });
    speakers.forEach(function(speaker) {
      speaker.conferenceId = eventId;
      speaker.firstName = speaker.firstname;
      delete speaker.firstname;
      speaker.lastName = speaker.lastname;
      delete speaker.lastname;
      speaker.tweetHandle = speaker.tweethandle;
      return delete speaker.tweethandle;
    });
    return async.map(speakers, synchronizeDevoxxSpeaker, function(err, results) {
      return console.log("Synchronized " + results.length + " Speakers");
    });
  });
};

processDevoxxPresentations = function(callback) {
  console.log("Start synchronizing Devoxx Presentations ...");
  return request.get({
    url: "" + baseUrl + "/rest/v1/events/" + eventId + "/presentations",
    json: true
  }, function(error, data, response) {
    var presentations;
    presentations = _(response).sortBy(function(presentation) {
      return ("" + presentation.title).toUpperCase();
    });
    presentations.forEach(function(presentation) {
      presentation.conferenceId = eventId;
      if (presentation.speakers) {
        return presentation.speakers.forEach(function(speaker) {
          speaker.id = speaker.speakerId;
          delete speaker.speakerId;
          speaker.name = speaker.speaker;
          delete speaker.speaker;
          speaker.uri = speaker.speakerUri;
          return delete speaker.speakerUri;
        });
      } else {
        return presentation.speakers = [];
      }
    });
    return async.map(presentations, synchronizeDevoxxPresentation, function(err, results) {
      return console.log("Synchronized " + results.length + " Presentations");
    });
  });
};

processDevoxxRooms = function(callback) {
  console.log("Start synchronizing Devoxx Rooms ...");
  return request.get({
    url: "" + baseUrl + "/rest/v1/events/" + eventId + "/schedule/rooms",
    json: true
  }, function(error, data, response) {
    var rooms;
    rooms = _(response).sortBy(function(room) {
      return ("" + room.title).toUpperCase();
    });
    rooms.forEach(function(room) {
      return room.conferenceId = eventId;
    });
    return async.map(rooms, synchronizeDevoxxRoom, function(err, results) {
      return console.log("Synchronized " + results.length + " Rooms");
    });
  });
};

processDevoxxSchedule = function(callback) {
  console.log("Start synchronizing Devoxx Schedule ...");
  return request.get({
    url: "" + baseUrl + "/rest/v1/events/" + eventId + "/schedule",
    json: true
  }, function(error, data, response) {
    var scheduleEntries;
    scheduleEntries = _(response).sortBy(function(scheduleEntry) {
      return "" + scheduleEntry.fromTime;
    });
    scheduleEntries.forEach(function(scheduleEntry) {
      scheduleEntry.conferenceId = eventId;
      if (scheduleEntry.speakers) {
        scheduleEntry.speakers = _(scheduleEntry.speakers).unique();
        scheduleEntry.speakers.forEach(function(speaker) {
          speaker.id = speaker.speakerId;
          delete speaker.speakerId;
          speaker.name = speaker.speaker;
          delete speaker.speaker;
          speaker.uri = speaker.speakerUri;
          return delete speaker.speakerUri;
        });
      } else {
        scheduleEntry.speakers = [];
      }
      delete scheduleEntry.speaker;
      delete scheduleEntry.speakerId;
      delete scheduleEntry.speakerUri;
      if (scheduleEntry.presentationId && scheduleEntry.title) {
        scheduleEntry.presentation = {
          id: scheduleEntry.presentationId,
          title: scheduleEntry.title,
          uri: scheduleEntry.presentationUri
        };
      }
      delete scheduleEntry.presentationId;
      delete scheduleEntry.presentationUri;
      scheduleEntry.fromTime = moment(scheduleEntry.fromTime, "YYYY-MM-DD HH:mm:ss.Z");
      return scheduleEntry.toTime = moment(scheduleEntry.toTime, "YYYY-MM-DD HH:mm:ss.Z");
    });
    return async.map(scheduleEntries, synchronizeDevoxxScheduleEntry, function(err, results) {
      return console.log("Synchronized " + results.length + " Schedule Entries");
    });
  });
};

synchronizeDevoxxExperienceLevel = function(experienceLevel, callback) {
  var query;
  query = {
    name: experienceLevel.name,
    conferenceId: experienceLevel.conferenceId
  };
  return ExperienceLevel.findOne(query, function(err, experienceLevelFound) {
    if (err || experienceLevelFound) {
      return callback(err, experienceLevelFound != null ? experienceLevelFound.name : void 0);
    } else {
      experienceLevel.name = experienceLevel.Name;
      delete experienceLevel.Name;
      new ExperienceLevel(experienceLevel).save(function(err) {});
      callback(err, experienceLevel.name);
      return console.log("New Experience Level synchronised: " + experienceLevel.name);
    }
  });
};

synchronizeDevoxxPresentationType = function(presentationType, callback) {
  var query;
  query = {
    id: presentationType.id,
    conferenceId: presentationType.conferenceId
  };
  return PresentationType.findOne(query, function(err, presentationTypeFound) {
    var updatedData;
    if (err) {
      return callback(err);
    } else if (presentationTypeFound) {
      if (utils.isNotSame(presentationType, presentationTypeFound, ["name", "description", "descriptionPlainText"])) {
        updatedData = {
          name: presentationType.name,
          description: presentationType.description,
          descriptionPlainText: presentationType.descriptionPlainText
        };
        return PresentationType.update(query, updatedData, function(err, numberAffected, raw) {
          return callback(err, presentationTypeFound != null ? presentationTypeFound.id : void 0);
        });
      } else {
        return callback(err, presentationTypeFound.id);
      }
    } else {
      return new PresentationType(presentationType).save(function(err) {
        console.log("New Presentation Type synchronized: " + presentationType.name);
        return callback(err, presentationType.id);
      });
    }
  });
};

synchronizeDevoxxTrack = function(track, callback) {
  var query;
  query = {
    id: track.id,
    conferenceId: track.conferenceId
  };
  return Track.findOne(query, function(err, trackFound) {
    var updatedData;
    if (err) {
      return callback(err);
    } else if (trackFound) {
      if (utils.isNotSame(track, trackFound, ["name", "description", "descriptionPlainText"])) {
        updatedData = {
          name: track.name,
          description: track.description,
          descriptionPlainText: track.descriptionPlainText
        };
        return Track.update(query, updatedData, function(err, numberAffected, raw) {
          return callback(err, trackFound != null ? trackFound.id : void 0);
        });
      } else {
        return callback(err, trackFound.id);
      }
    } else {
      return new Track(track).save(function(err) {
        console.log("New Track synchronized: " + track.name);
        return callback(err, track.id);
      });
    }
  });
};

synchronizeDevoxxSpeaker = function(speaker, callback) {
  var query;
  query = {
    id: speaker.id,
    conferenceId: speaker.conferenceId
  };
  return Speaker.findOne(query, function(err, speakerFound) {
    var updatedData;
    if (err) {
      return callback(err);
    } else if (speakerFound) {
      if (utils.isNotSame(speaker, speakerFound, ["lastName", "bio", "company", "imageURI", "firstName", "tweethandle"])) {
        updatedData = {
          lastName: speaker.lastName,
          bio: speaker.bio,
          company: speaker.company,
          imageURI: speaker.imageURI,
          firstName: speaker.firstName,
          tweetHandle: speaker.tweetHandle
        };
        return Speaker.update(query, updatedData, function(err, numberAffected, raw) {
          return callback(err, speakerFound != null ? speakerFound.id : void 0);
        });
      } else {
        return callback(err, speakerFound.id);
      }
    } else {
      return new Speaker(speaker).save(function(err) {
        console.log("New Speaker synchronized: " + speaker.firstName + " " + speaker.lastName);
        return callback(err, speaker.id);
      });
    }
  });
};

synchronizeDevoxxPresentation = function(presentation, callback) {
  var query;
  query = {
    id: presentation.id,
    conferenceId: presentation.conferenceId
  };
  return Presentation.findOne(query, function(err, presentationFound) {
    var updatedData;
    if (err) {
      return callback(err);
    } else if (presentationFound) {
      if (utils.isNotSame(presentation, presentationFound, ["summary", "title", "track", "experience", "language", "type", "room"])) {
        updatedData = {
          summary: presentation.summary,
          title: presentation.title,
          track: presentation.track,
          experience: presentation.experience,
          language: presentation.language,
          type: presentation.type,
          room: presentation.room
        };
        return Presentation.update(query, updatedData, function(err, numberAffected, raw) {
          return callback(err, presentationFound != null ? presentationFound.id : void 0);
        });
      } else {
        return callback(err, presentationFound.id);
      }
    } else {
      return new Presentation(presentation).save(function(err) {
        console.log("New Presentation synchronized: " + presentation.title);
        return callback(err, presentation.id);
      });
    }
  });
};

synchronizeDevoxxRoom = function(room, callback) {
  var query;
  query = {
    id: room.id,
    conferenceId: room.conferenceId
  };
  return Room.findOne(query, function(err, roomFound) {
    var updatedData;
    if (err) {
      return callback(err);
    } else if (roomFound) {
      if (utils.isNotSame(room, roomFound, ["name", "capacity", "locationName"])) {
        updatedData = {
          name: room.name,
          capacity: room.capacity,
          locationName: room.locationName
        };
        return Room.update(query, updatedData, function(err, numberAffected, raw) {
          return callback(err, roomFound != null ? roomFound.id : void 0);
        });
      } else {
        return callback(err, roomFound.id);
      }
    } else {
      return new Room(room).save(function(err) {
        console.log("New Room synchronized: " + room.name);
        return callback(err, room.id);
      });
    }
  });
};

synchronizeDevoxxScheduleEntry = function(scheduleEntry, callback) {
  var query;
  query = {
    id: scheduleEntry.id,
    conferenceId: scheduleEntry.conferenceId
  };
  return ScheduleEntry.findOne(query, function(err, scheduleEntryFound) {
    var updatedData;
    if (err) {
      return callback(err);
    } else if (scheduleEntryFound) {
      if (utils.isNotSame(scheduleEntry, scheduleEntryFound, ["partnerSlot", "title", "code", "type", "kind", "room", "fromTime", "toTime", "note"])) {
        updatedData = {
          partnerSlot: scheduleEntry.partnerSlot,
          title: scheduleEntry.title,
          code: scheduleEntry.code,
          type: scheduleEntry.type,
          kind: scheduleEntry.kind,
          room: scheduleEntry.room,
          fromTime: scheduleEntry.fromTime,
          toTime: scheduleEntry.toTime,
          note: scheduleEntry.note
        };
        return ScheduleEntry.update(query, updatedData, function(err, numberAffected, raw) {
          return callback(err, scheduleEntryFound != null ? scheduleEntryFound.id : void 0);
        });
      } else {
        return callback(err, scheduleEntryFound.id);
      }
    } else {
      return new ScheduleEntry(scheduleEntry).save(function(err) {
        console.log("New Schedule Entry synchronized: " + scheduleEntry.title);
        return callback(err, scheduleEntry.id);
      });
    }
  });
};

module.exports = {
  synchronize: synchronize
};

/*
//@ sourceMappingURL=syncDevoxxBelgium.map
*/
