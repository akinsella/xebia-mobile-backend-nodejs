// Generated by CoffeeScript 1.6.3
var Event, apns, async, config, db, eventProps, extractEvents, moment, organizerProps, processEventBriteEntries, request, synchronize, synchronizeEvent, transformEvent, utils, venueProps, _,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

utils = require('../lib/utils');

async = require('async');

_ = require('underscore')._;

Event = require("../model/event");

db = require("../db");

moment = require("moment");

config = require("../conf/config");

request = require("request");

apns = require("../lib/apns");

eventProps = ["id", "category", "capacity", "title", "startDate", "endDate", "timezoneOffset", "tags", "created", "url", "privacy", "status", "description", "descriptionPlainText", "organizer", "venue"];

organizerProps = ["id", "name", "url", "description"];

venueProps = ["id", "name", "city", "region", "country", "countryCode", "address", "address2", "postalCode", "longitude", "latitude"];

synchronize = function() {
  var callback;
  callback = function(err, news) {
    if (err) {
      return console.log("EventBrite Synchronization ended with error: " + err.message + " - Error: " + err);
    } else {
      return console.log("EventBrite Synchronization ended with success ! (" + news.length + " events synchronized)");
    }
  };
  if (config.feature.stopWatch) {
    callback = utils.stopWatchCallbak(callback);
  }
  console.log("Start synchronizing EventBrite entries ...");
  return processEventBriteEntries(callback);
};

processEventBriteEntries = function(callback) {
  var apiKey;
  apiKey = process.env["EVENTBRITE_AUTH_KEY"];
  "https://www.eventbrite.com/json/organizer_list_events?app_key=" + apiKey + "&id=1627902102";
  return request.get({
    url: "https://www.eventbrite.com/json/organizer_list_events?app_key=" + apiKey + "&id=1627902102",
    json: true
  }, function(error, data, response) {
    var events;
    events = _(extractEvents(response)).sortBy(function(event) {
      return event.startDate;
    });
    return async.map(events, synchronizeEvent, callback);
  });
};

synchronizeEvent = function(event, callback) {
  return Event.findOne({
    id: event.id
  }, function(err, foundEvent) {
    var eventEntry;
    if (err) {
      return callback(err);
    } else if (!foundEvent) {
      eventEntry = new Event(event);
      return eventEntry.save(function(err) {
        callback(err, eventEntry.id);
        return apns.pushToAll("New event with id: " + eventEntry.id, function() {
          return console.log("Pushed notification for new event wth id: " + eventEntry.id);
        });
      });
    } else {
      return callback(err, foundEvent.id);
    }
  });
};

extractEvents = function(data) {
  return _.chain(data.events).pluck("event").sortBy(function(event) {
    return event.start_date;
  }).filter(function(event) {
    return event.status === "Live" || event.status === "Completed";
  }).reverse().map(transformEvent).value();
};

transformEvent = function(event) {
  var key, oKey, vKey;
  event.descriptionPlainText = event.description;
  if (event.descriptionPlainText) {
    event.descriptionPlainText = event.descriptionPlainText.replace(/<\/?([a-z][a-z0-9]*)\b[^>]*>?/gi, '');
    event.descriptionPlainText = event.descriptionPlainText.replace(/<!--(.*?)-->/g, '');
    event.descriptionPlainText = event.descriptionPlainText.replace(/\n\s*\n/g, '\n');
  }
  event.startDate = event.start_date;
  delete event.start_date;
  event.endDate = event.end_date;
  delete event.end_date;
  event.timezoneOffset = event.timezone_offset;
  delete event.timezone_offset;
  event.venue.countryCode = event.venue.country_code;
  delete event.venue.country_code;
  event.venue.address2 = event.venue.address_2;
  delete event.venue.address_2;
  event.venue.postalCode = event.venue.postal_code;
  delete event.venue.postal_code;
  for (key in event) {
    if (!(__indexOf.call(eventProps, key) >= 0)) {
      delete event[key];
    }
    for (vKey in event.venue) {
      if (!(__indexOf.call(venueProps, vKey) >= 0)) {
        delete event.venue[vKey];
      }
    }
    for (oKey in event.organizer) {
      if (!(__indexOf.call(organizerProps, oKey) >= 0)) {
        delete event.organizer[oKey];
      }
    }
  }
  return event;
};

module.exports = {
  synchronize: synchronize
};

/*
//@ sourceMappingURL=syncEventBrite.map
*/
