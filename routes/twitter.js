// Generated by CoffeeScript 1.6.2
var processRequest, redis, retweetedStatusProps, retweetedStatusUserProps, shortenTweet, stream_xebiafr, tweetProps, tweetUserProps, twit, twitter, user_timeline, user_timeline_authenticated, utils, xebiaFrTweets, _,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

twitter = require('ntwitter');

utils = require('../lib/utils');

redis = require('../lib/redis');

_ = require('underscore')._;

twit = new twitter({
  consumer_key: process.env.OAUTH_TWITTER_CONSUMER_KEY,
  consumer_secret: process.env.OAUTH_TWITTER_CONSUMER_SECRET,
  access_token_key: process.env.OAUTH_TWITTER_ACCESS_TOKEN_KEY,
  access_token_secret: process.env.OAUTH_TWITTER_ACCESS_TOKEN_SECRET
});

xebiaFrTweets = [];

twit.stream('user', {
  track: 'XebiaFr'
}, function(stream) {
  stream.on('data', function(data) {
    var tweet;

    console.log(data);
    tweet = data;
    if (xebiaFrTweets.length > 100) {
      xebiaFrTweets.splice(100);
    }
    return xebiaFrTweets.unshift(shortenTweet(tweet));
  });
  stream.on('end', function(response) {
    return console.log('Twitter Stream Connection End: ' + response);
  });
  stream.on('destroy', function(response) {
    return console.log('Twitter Stream Connection destroyed: ' + response);
  });
});

stream_xebiafr = function(req, res) {
  var callback;

  callback = getParameterByName(req.url, 'callback');
  res.send(callback != null ? callback : callback + "(" + JSON.stringify(xebiaFrTweets) + {
    ");": JSON.stringify(xebiaFrTweets)
  });
};

user_timeline_authenticated = function(req, res) {
  var callback, user;

  user = req.params.user;
  console.log("User: " + user);
  callback = getParameterByName(req.url, 'callback');
  redis.client.get(req.url, function(err, data) {
    if (!err && data) {
      console.log("[" + req.url + "] A reply is in cache key: '" + utils.getCacheKey(req) + "', returning immediatly the reply");
      return utils.responseData(200, "", data, {
        callback: callback,
        req: req,
        res: res
      });
    } else {
      console.log("[" + req.url + "] No cached reply found for key: '" + utils.getCacheKey(req) + "'");
      return twit.getUserTimeline("screen_name=" + user + "&contributor_details=false&include_entities=true&include_rts=true&exclude_replies=false&count=50&exclude_replies=false", function(error, data) {
        var errorMessage, jsonData, tweets, tweetsShortened;

        if (error) {
          errorMessage = err.name + ": " + err.message;
          return utils.responseData(500, errorMessage, void 0, {
            callback: callback,
            req: req,
            res: res
          });
        } else {
          tweets = data;
          tweetsShortened = [];
          _(tweets).each(function(tweet) {
            return tweetsShortened.push(shortenTweet(tweet));
          });
          jsonData = JSON.stringify(tweetsShortened);
          redis.client.set(utils.getCacheKey(req), jsonData);
          redis.client.expire(utils.getCacheKey(req), 60 * 60);
          console.log("[" + req.url + "] Fetched Response from url: " + jsonData);
          return callback(200, "", jsonData, {
            callback: callback,
            req: req,
            res: res
          });
        }
      });
    }
  });
};

processRequest = function(req, res, url, transform) {
  var options;

  options = utils.buildOptions(req, res, url, 5, transform);
  utils.processRequest(options);
};

tweetProps = ["id", "id_str", "created_at", "text", "favorited", "retweeted", "retweet_count", "entities", "retweeted_status", "user"];

tweetUserProps = ["id", "id_str", "screen_name", "name", "profile_image_url"];

retweetedStatusProps = ["id", "id_str", "created_at", "text", "favorited", "retweeted", "retweet_count", "entities", "user"];

retweetedStatusUserProps = ["id", "id_str", "screen_name", "name", "profile_image_url"];

shortenTweet = function(tweet) {
  var eKey, entities, indices, rtKey, rtuKey, tKey, tuKey, _ref, _ref1;

  for (tKey in tweet) {
    if (!(__indexOf.call(tweetProps, tKey) >= 0)) {
      delete tweet[tKey];
    }
  }
  if (tweet.entities) {
    _ref = tweet.entities;
    for (eKey in _ref) {
      entities = _ref[eKey];
      indices = [];
      _(entities).each(function(entity) {
        _(entity.indices).each(function(indice) {
          return indices.push({
            indice: indice
          });
        });
        return entity.indices = indices;
      });
    }
  }
  if (tweet.user) {
    for (tuKey in tweet.user) {
      if (!(__indexOf.call(tweetUserProps, tuKey) >= 0)) {
        delete tweet.user[tuKey];
      }
    }
  }
  if (tweet.retweeted_status) {
    if (tweet.retweeted_status.entities) {
      _ref1 = tweet.retweeted_status.entities;
      for (eKey in _ref1) {
        entities = _ref1[eKey];
        indices = [];
        _(entities).each(function(entity) {
          _(entity.indices).each(function(indice) {
            return indices.push({
              indice: indice
            });
          });
          return entity.indices = indices;
        });
      }
    }
    for (rtKey in tweet.retweeted_status) {
      if (!(__indexOf.call(retweetedStatusProps, rtKey) >= 0)) {
        delete tweet.retweeted_status[rtKey];
      }
    }
    if (tweet.retweeted_status.user) {
      for (rtuKey in tweet.retweeted_status.user) {
        if (!(__indexOf.call(retweetedStatusUserProps, rtuKey) >= 0)) {
          delete tweet.retweeted_status.user[rtuKey];
        }
      }
    }
  }
  return tweet;
};

user_timeline = function(req, res) {
  var twitterUrl, user;

  user = req.params.user;
  console.log("User: " + user);
  twitterUrl = "http://api.twitter.com/1/statuses/user_timeline.json?screen_name=" + user + "&contributor_details=false&include_entities=true&include_rts=true&exclude_replies=false&count=50&exclude_replies=false";
  console.log("Twitter Url: " + twitterUrl);
  return processRequest(req, res, twitterUrl, function(data) {
    _(data).each(function(tweet) {
      return shortenTweet(tweet);
    });
    return data;
  });
};

module.exports = {
  stream_xebiafr: stream_xebiafr,
  user_timeline_authenticated: user_timeline_authenticated,
  user_timeline: user_timeline
};
