// Generated by CoffeeScript 1.6.3
var Cache, OAuth, OAuth2, cache, fetchTwitterData, oauth2, processRequest, request, retweetedStatusProps, retweetedStatusUserProps, shortenTweet, stream_xebiafr, tweetProps, tweetUserProps, twit, twitter, twitterConsumerKey, twitterConsumerSecret, user_timeline_authenticated, utils, xebiaFrTweets, xebia_timeline, _,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

twitter = require('ntwitter');

utils = require('../lib/utils');

request = require('request');

cache = require('../lib/cache');

_ = require('underscore')._;

OAuth = require('OAuth');

Cache = require('../lib/cache');

twit = new twitter({
  consumer_key: process.env["TWITTER_OAUTH_CONSUMER_KEY"],
  consumer_secret: process.env["TWITTER_OAUTH_CONSUMER_SECRET"],
  access_token_key: process.env["TWITTER_OAUTH_ACCESS_TOKEN_KEY"],
  access_token_secret: process.env["TWITTER_OAUTH_ACCESS_TOKEN_SECRET"]
});

OAuth2 = OAuth.OAuth2;

twitterConsumerKey = process.env["TWITTER_OAUTH_CONSUMER_KEY"];

twitterConsumerSecret = process.env["TWITTER_OAUTH_CONSUMER_SECRET"];

oauth2 = new OAuth2(twitterConsumerKey, twitterConsumerSecret, 'https://api.twitter.com/', null, 'oauth2/token', null);

oauth2.useAuthorizationHeaderforGET(true);

xebiaFrTweets = [];

twit.stream('user', {
  track: 'XebiaFr'
}, function(stream) {
  stream.on('data', function(data) {
    var tweet;
    console.log(data);
    tweet = data;
    if (xebiaFrTweets.length > 100) {
      xebiaFrTweets.splice(100);
    }
    return xebiaFrTweets.unshift(shortenTweet(tweet));
  });
  stream.on('end', function(response) {
    return console.log('Twitter Stream Connection End: ' + response);
  });
  return stream.on('destroy', function(response) {
    return console.log('Twitter Stream Connection destroyed: ' + response);
  });
});

stream_xebiafr = function(req, res) {
  var callback;
  callback = getParameterByName(req.url, 'callback');
  return res.send(callback != null ? callback : callback + "(" + JSON.stringify(xebiaFrTweets) + {
    ");": JSON.stringify(xebiaFrTweets)
  });
};

user_timeline_authenticated = function(req, res) {
  var callback, user;
  user = req.params.user;
  console.log("User: " + user);
  callback = getParameterByName(req.url, 'callback');
  return cache.get(req.url, function(err, data) {
    if (!err && data) {
      console.log("[" + req.url + "] A reply is in cache key: '" + utils.getCacheKey(req) + "', returning immediatly the reply");
      return utils.responseData(200, "", data, {
        callback: callback,
        req: req,
        res: res
      });
    } else {
      console.log("[" + req.url + "] No cached reply found for key: '" + utils.getCacheKey(req) + "'");
      return twit.getUserTimeline("screen_name=" + user + "&contributor_details=false&include_entities=true&include_rts=true&exclude_replies=false&count=50&exclude_replies=false", function(error, data) {
        var errorMessage, jsonData, tweets, tweetsShortened;
        if (error) {
          errorMessage = err.name + ": " + err.message;
          return utils.responseData(500, errorMessage, void 0, {
            callback: callback,
            req: req,
            res: res
          });
        } else {
          tweets = data;
          tweetsShortened = [];
          _(tweets).each(function(tweet) {
            return tweetsShortened.push(shortenTweet(tweet));
          });
          jsonData = JSON.stringify(tweetsShortened);
          cache.set(utils.getCacheKey(req), jsonData, 60 * 60);
          console.log("[" + req.url + "] Fetched Response from url: " + jsonData);
          return callback(200, "", jsonData, {
            callback: callback,
            req: req,
            res: res
          });
        }
      });
    }
  });
};

processRequest = function(req, res, url, oauth, credentials, transform) {
  var options;
  options = {
    req: req,
    res: res,
    url: url,
    cacheKey: utils.getCacheKey(req),
    forceNoCache: utils.getIfUseCache(req),
    cacheTimeout: 5 * 60,
    callback: utils.responseData,
    transform: transform,
    oauth2: oauth2,
    credentials: credentials
  };
  return utils.processRequest(options);
};

xebia_timeline = function(req, res) {
  var twitterUrl;
  twitterUrl = "https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name=XebiaFR&contributor_details=false&include_entities=true&include_rts=true&exclude_replies=false&count=50&exclude_replies=false";
  console.log("Twitter Url: " + twitterUrl);
  return Cache.get('twitter.credentials', function(err, credentials) {
    if (err) {
      return utils.responseData(500, "", err, {
        req: req,
        res: res
      });
    } else if (credentials) {
      return fetchTwitterData(twitterUrl, credentials, req, res);
    } else {
      return oauth2.getOAuthAccessToken('', {
        'grant_type': 'client_credentials'
      }, function(err, accessToken, refreshToken, results) {
        credentials = {
          accessToken: accessToken
        };
        if (err) {
          return utils.responseData(500, "", err, {
            req: req,
            res: res
          });
        } else {
          return Cache.set('twitter.credentials', credentials, -1, function(err) {
            if (err) {
              return utils.responseData(500, "", err, {
                req: req,
                res: res
              });
            } else {
              return fetchTwitterData(twitterUrl, credentials, req, res);
            }
          });
        }
      });
    }
  });
};

fetchTwitterData = function(twitterUrl, credentials, req, res) {
  return processRequest(req, res, twitterUrl, oauth2, credentials, function(data) {
    _(JSON.parse(data)).each(function(tweet) {
      return shortenTweet(tweet);
    });
    return data;
  });
};

tweetProps = ["id", "id_str", "created_at", "text", "favorited", "retweeted", "retweet_count", "entities", "retweeted_status", "user"];

tweetUserProps = ["id", "id_str", "screen_name", "name", "profile_image_url"];

retweetedStatusProps = ["id", "id_str", "created_at", "text", "favorited", "retweeted", "retweet_count", "entities", "user"];

retweetedStatusUserProps = ["id", "id_str", "screen_name", "name", "profile_image_url"];

shortenTweet = function(tweet) {
  var eKey, entities, indices, rtKey, rtuKey, tKey, tuKey, _ref, _ref1;
  for (tKey in tweet) {
    if (!(__indexOf.call(tweetProps, tKey) >= 0)) {
      delete tweet[tKey];
    }
  }
  if (tweet.entities) {
    _ref = tweet.entities;
    for (eKey in _ref) {
      entities = _ref[eKey];
      indices = [];
      _(entities).each(function(entity) {
        _(entity.indices).each(function(indice) {
          return indices.push({
            indice: indice
          });
        });
        return entity.indices = indices;
      });
    }
  }
  if (tweet.user) {
    for (tuKey in tweet.user) {
      if (!(__indexOf.call(tweetUserProps, tuKey) >= 0)) {
        delete tweet.user[tuKey];
      }
    }
  }
  if (tweet.retweeted_status) {
    if (tweet.retweeted_status.entities) {
      _ref1 = tweet.retweeted_status.entities;
      for (eKey in _ref1) {
        entities = _ref1[eKey];
        indices = [];
        _(entities).each(function(entity) {
          _(entity.indices).each(function(indice) {
            return indices.push({
              indice: indice
            });
          });
          return entity.indices = indices;
        });
      }
    }
    for (rtKey in tweet.retweeted_status) {
      if (!(__indexOf.call(retweetedStatusProps, rtKey) >= 0)) {
        delete tweet.retweeted_status[rtKey];
      }
    }
    if (tweet.retweeted_status.user) {
      for (rtuKey in tweet.retweeted_status.user) {
        if (!(__indexOf.call(retweetedStatusUserProps, rtuKey) >= 0)) {
          delete tweet.retweeted_status.user[rtuKey];
        }
      }
    }
  }
  return tweet;
};

module.exports = {
  stream_xebiafr: stream_xebiafr,
  user_timeline_authenticated: user_timeline_authenticated,
  xebia_timeline: xebia_timeline
};
